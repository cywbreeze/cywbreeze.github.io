<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java8_新特性</title>
      <link href="/2022/11/03/java8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2022/11/03/java8-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h1><ul><li><p>速度更快</p></li><li><p>代码更少（增加了新的语法：Lambda表达式）</p></li><li><p>强大的Stream API</p></li><li><p><strong>Date Time API</strong> − 加强对日期与时间的处理</p></li><li><p>便于并行</p></li><li><p>最大化减少空指针的异常： <strong>Optional类</strong></p></li><li><p>Nashorn 引擎，允许在JVM上运行JS应用</p></li></ul><h2 id="Ⅰ、Lambda-表达式"><a href="#Ⅰ、Lambda-表达式" class="headerlink" title="Ⅰ、Lambda 表达式"></a>Ⅰ、Lambda 表达式</h2><blockquote><p><strong>Lambda 是一个匿名函数，Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），我们可以把Lambda表达式理解为一段可以传递的代码（将代码像数据一样进行传递）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。</strong></p></blockquote><p><strong>1.举例：</strong></p><ul><li>Comparator<Integer> com2 &#x3D; (o1,o2) -&gt; o1.compareTo(o2)</li></ul><p><strong>2.格式：</strong></p><p>​-&gt; ： Lambda操作符 或 箭头操作符</p><p>​-&gt;左边：Lambda形参列表 （其实就是接口中抽象方法的形参列表）</p><p>​-&gt;右边： Lambda体 （其实就是重写抽象方法的方法体）</p><p><strong>3.Lambda的使用（分六种情况）</strong></p><ul><li>总结<ul><li>-&gt;左边：Lambda 形参列表的参数类型可以省略； 如果Lambda参数列表只有一个参数，其一对 ( ) 可以省略；若Lambda 需要两个或以上的参数，多条执行语句，则不需要省略。</li><li>-&gt;右边：Lambda体使用一对{ }包裹；如果Lambda体只有一条语句，则可以省略 { } 以及 return 关键字。</li></ul></li></ul><p><strong>4.Lambda表达式的本质：作为接口的实例</strong></p><ul><li><p>语法格式一： 无参，无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//普通写法</span><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run &#123;<br>                System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>       &#125;;<br>       r1.run();<br>    <br>   <span class="hljs-comment">//Lambda 表达式写法</span><br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>       r2.run();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>语法格式二：Lambda 需要一个参数，但是没有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest1</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//普通写法</span><br>    Consumer&lt;String&gt; con = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;;<br>    con.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br><span class="hljs-comment">//Lambda 表达式写法 </span><br><span class="hljs-comment">//大括号&#123;&#125;可以省略</span><br>    Consumer&lt;String&gt; con1 =  (String s) -&gt;  &#123;System.out.println(s);&#125;;<br>    con1.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“&#x3D;&#x3D;类型推断&#x3D;&#x3D;”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest2</span><span class="hljs-params">()</span>&#123;、<br>    Consumer&lt;String&gt; con1 =  (String s) -&gt;  &#123;System.out.println(s);&#125;;<br>    con1.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-comment">//省略String</span><br>    Consumer&lt;String&gt; con2 =  (s) -&gt;  &#123;System.out.println(s);&#125;;<br>    con2.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>语法格式四：Lambda 若只需要&#x3D;&#x3D;一个参数&#x3D;&#x3D;时，参数的小括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest3</span><span class="hljs-params">()</span>&#123;<br><br>    Consumer&lt;String&gt; con =  (s) -&gt;  &#123;System.out.println(s);&#125;;<br>    con.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-comment">//省略括号</span><br>    Consumer&lt;String&gt; con1 =  s -&gt;  &#123;System.out.println(s);&#125;;<br>    con1.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>语法格式五：Lambda  若只需要两个或以上的参数，多条执行语句，并且可以又返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest4</span><span class="hljs-params">()</span>&#123;<br>    Comparator&lt;Integer&gt; com1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>            System.out.println(o1);<br>            System.out.println(o2);<br>            <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//Lambda 表达式如下</span><br>    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123;<br>        System.out.println(o1);<br>        System.out.println(o2);<br>        <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>    &#125;;<br>   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>语法格式六：当Lambda 体只有&#x3D;&#x3D;一条语句&#x3D;&#x3D;时，return与大括号若有，都可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest5</span><span class="hljs-params">()</span>&#123;<br>    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; &#123;<br>        <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>    &#125;;<br><br>    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Ⅱ、函数式接口"><a href="#Ⅱ、函数式接口" class="headerlink" title="Ⅱ、函数式接口"></a>Ⅱ、函数式接口</h2><ul><li><p>如果一个接口中只申明了一个抽象方法，则此接口称为函数式接口</p></li><li><p>函数式接口可以被隐式转换为 lambda 表达式。</p></li><li><p>Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。在接口上使用 <code>@FunctionalInterface 注解</code>，这样可以检查他是否是一个函数式接口</p></li><li><p>如定义了一个函数式接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GreetingService</span> <br>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayMessage</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GreetingService</span> <span class="hljs-variable">greetService1</span> <span class="hljs-operator">=</span> <br>     message -&gt; System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br></code></pre></td></tr></table></figure></li></ul><ol><li><p><strong>java内置的核心函数式接口</strong></p><ul><li>消费型接口 Consumer<T>  void accept（T  t）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest5</span><span class="hljs-params">()</span>&#123;<br>    happy(<span class="hljs-number">500</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Double&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Double aDouble)</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello world:&quot;</span> + aDouble);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//函数式接口如下</span><br>    happy(<span class="hljs-number">500</span>,money -&gt;  System.out.println(<span class="hljs-string">&quot;hello world:&quot;</span> + money));<br>    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-type">double</span> money,Consumer&lt;Double&gt; con)</span>&#123;<br>    con.accept(money);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="Ⅲ、方法引用"><a href="#Ⅲ、方法引用" class="headerlink" title="Ⅲ、方法引用"></a>Ⅲ、方法引用</h2><ul><li><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。</p></li><li><p>方法引用通过方法的名字来指向一个方法。</p></li><li><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p>方法引用使用一对冒号 <strong>::</strong> 将类（或对象）与方法名隔开。</p></li><li><p>如下三种使用情况：</p><ul><li><p>对象 <strong>::</strong> 实例方法名</p></li><li><p>类**::**静态方法名</p></li><li><p>类**::**实例方法名</p></li><li><p>1.使用情境： 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p></li><li><p>2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例，所以方法引用，也是函数式接口的实例。</p></li><li><p>3.使用格式： 类（或对象）**::**  方法名</p></li><li><p>4.方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的形参列表和返回值类型相同！！！</p></li></ul></li></ul><p>情况一：对象 <strong>::</strong> 实例方法</p><ul><li><p>Consumer中的void accept（T t）</p></li><li><p>PrintStream中的void println（T t）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest5</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//Lambda 表达式</span><br>   Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);<br>   con1.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-comment">//方法引用</span><br>    <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> System.out;<br>    Consumer&lt;String&gt; con2 = ps::println;<br>    con2.accept(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>情况二：类 <strong>::</strong> 静态方法</p><ul><li><p>Comparator中的int  compare(T t1, T t2)</p></li><li><p>Integer中的int compare(T t1, T t2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest6</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//Lambda表达式    </span><br>   Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);<br>   System.out.println(com1.compare(<span class="hljs-number">12</span>,<span class="hljs-number">21</span>));<br><span class="hljs-comment">//方法引用</span><br>   Comparator&lt;Integer&gt; com2 =  Integer::compare;   <br>   System.out.println(com2.compare(<span class="hljs-number">12</span>,<span class="hljs-number">21</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>情况一：类 <strong>::</strong> 实例方法（有难度）</p><ul><li><p>Comparator中的int  compare(T t1, T t2)</p></li><li><p>String中的int  t1.compareTo( t2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaTest5</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//Lambda表达式</span><br>   Comparator&lt;String&gt; com1 = (t1,t2) -&gt; t1.compareTo(t2);<br>   System.out.println(com1.compare(<span class="hljs-string">&quot;12&quot;</span>,<span class="hljs-string">&quot;21&quot;</span>));<br><span class="hljs-comment">//方法引用</span><br>   Comparator&lt;String&gt; com2 =  String::compareTo;<br>   System.out.println(com2.compare(<span class="hljs-string">&quot;12&quot;</span>,<span class="hljs-string">&quot;21&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Ⅳ、Stream-API"><a href="#Ⅳ、Stream-API" class="headerlink" title="Ⅳ、Stream API"></a>Ⅳ、Stream API</h2><ul><li><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p></li><li><p>Stream API 对集合数据进行操作，就类似与用 SQL 语句执行的数据库查询</p></li><li><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p></li><li><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p></li><li><p>stream 和 Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的，或者说前者面向内存的，后者面向CPU,通过CPU实现计算。</p></li><li><p>集合讲的是数据，Stream讲的是计算！</p></li><li><p><strong>注意</strong></p><ul><li>Stream并不会存储元素，而是按需计算。</li><li>Stream不会改变源对象，相反，它们回返回一个持有结果的新Stream。</li><li>Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行。</li></ul></li><li><p>Stream 执行流程</p><ul><li>Stream的实例化    </li><li>一系列的中间操作（过滤、映射…..）</li><li>终止操作</li></ul></li><li><p><strong>说明</strong>：</p><ul><li>一个中间操作链，对数据源进行处理</li><li>一旦执行终止操作，就执行中间操作链，并产生结果，之后，不会再被使用</li></ul></li></ul><h3 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h3><p>​多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否者中间操作不会执行任何的处理！ 而在终止操作时一次性全部处理，称为“惰性求值”。</p><h4 id="1-筛选与切片"><a href="#1-筛选与切片" class="headerlink" title="1-筛选与切片"></a>1-筛选与切片</h4><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。</p><p>1.filter(Predicate p) —接收Lambda，从流中排除某些元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br><span class="hljs-comment">// 获取空字符串的数量</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();<br></code></pre></td></tr></table></figure><p>2.distinct( )—筛选，通过流所生成的元素的hashCode( )和equals( )去除重复的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>,  <span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br><span class="hljs-comment">// 去除重复的元素</span><br>strings.stream().distinct().foreach(System.out::println);<br></code></pre></td></tr></table></figure><p>3.limit(long maxSize)—截断流，使其元素不超过给定数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br><span class="hljs-comment">// 获取前三个元素</span><br>strings.stream().limit(<span class="hljs-number">3</span>).foreach(System.out::println);<br></code></pre></td></tr></table></figure><p>4.skip(long n)—跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br><span class="hljs-comment">// 获取除了前三个剩下的元素</span><br>strings.stream().skip(<span class="hljs-number">3</span>).foreach(System.out::println);<br></code></pre></td></tr></table></figure><hr><h4 id="2-映射"><a href="#2-映射" class="headerlink" title="2-映射"></a>2-映射</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ul><li><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 获取对应的平方数</span><br>List&lt;Integer&gt; squaresList = numbers.stream().<br>                      map( i -&gt; i*i).distinct().foreach(System.out::println);<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="3-排序"><a href="#3-排序" class="headerlink" title="3-排序"></a>3-排序</h4><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><ul><li>&#96;&#96;&#96;java<br>Random random &#x3D; new Random();<br>random.ints().limit(10).sorted().forEach(System.out::println);</li></ul><pre><code>---## Ⅴ、Optional类+ Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。+ Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。+ Optional 类的引入很好的解决空指针异常。</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/02/hello-world/"/>
      <url>/2022/11/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
